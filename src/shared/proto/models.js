// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v6.31.0
// source: models.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { EmptyRequest, Metadata, StringArray, StringRequest } from "./common";
export const protobufPackage = "cline";
function createBaseVsCodeLmModelsArray() {
    return { models: [] };
}
export const VsCodeLmModelsArray = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.models) {
            VsCodeLmModel.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVsCodeLmModelsArray();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.models.push(VsCodeLmModel.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            models: globalThis.Array.isArray(object?.models) ? object.models.map((e) => VsCodeLmModel.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.models?.length) {
            obj.models = message.models.map((e) => VsCodeLmModel.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return VsCodeLmModelsArray.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVsCodeLmModelsArray();
        message.models = object.models?.map((e) => VsCodeLmModel.fromPartial(e)) || [];
        return message;
    },
};
function createBaseVsCodeLmModel() {
    return { vendor: "", family: "", version: "", id: "" };
}
export const VsCodeLmModel = {
    encode(message, writer = new BinaryWriter()) {
        if (message.vendor !== "") {
            writer.uint32(10).string(message.vendor);
        }
        if (message.family !== "") {
            writer.uint32(18).string(message.family);
        }
        if (message.version !== "") {
            writer.uint32(26).string(message.version);
        }
        if (message.id !== "") {
            writer.uint32(34).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVsCodeLmModel();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.vendor = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.family = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : "",
            family: isSet(object.family) ? globalThis.String(object.family) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            id: isSet(object.id) ? globalThis.String(object.id) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.vendor !== "") {
            obj.vendor = message.vendor;
        }
        if (message.family !== "") {
            obj.family = message.family;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return VsCodeLmModel.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVsCodeLmModel();
        message.vendor = object.vendor ?? "";
        message.family = object.family ?? "";
        message.version = object.version ?? "";
        message.id = object.id ?? "";
        return message;
    },
};
function createBasePriceTier() {
    return { tokenLimit: 0, price: 0 };
}
export const PriceTier = {
    encode(message, writer = new BinaryWriter()) {
        if (message.tokenLimit !== 0) {
            writer.uint32(8).int32(message.tokenLimit);
        }
        if (message.price !== 0) {
            writer.uint32(17).double(message.price);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePriceTier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.tokenLimit = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.price = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenLimit: isSet(object.tokenLimit) ? globalThis.Number(object.tokenLimit) : 0,
            price: isSet(object.price) ? globalThis.Number(object.price) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenLimit !== 0) {
            obj.tokenLimit = Math.round(message.tokenLimit);
        }
        if (message.price !== 0) {
            obj.price = message.price;
        }
        return obj;
    },
    create(base) {
        return PriceTier.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePriceTier();
        message.tokenLimit = object.tokenLimit ?? 0;
        message.price = object.price ?? 0;
        return message;
    },
};
function createBaseThinkingConfig() {
    return { maxBudget: undefined, outputPrice: undefined, outputPriceTiers: [] };
}
export const ThinkingConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.maxBudget !== undefined) {
            writer.uint32(8).int32(message.maxBudget);
        }
        if (message.outputPrice !== undefined) {
            writer.uint32(17).double(message.outputPrice);
        }
        for (const v of message.outputPriceTiers) {
            PriceTier.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThinkingConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.maxBudget = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.outputPrice = reader.double();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.outputPriceTiers.push(PriceTier.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxBudget: isSet(object.maxBudget) ? globalThis.Number(object.maxBudget) : undefined,
            outputPrice: isSet(object.outputPrice) ? globalThis.Number(object.outputPrice) : undefined,
            outputPriceTiers: globalThis.Array.isArray(object?.outputPriceTiers)
                ? object.outputPriceTiers.map((e) => PriceTier.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxBudget !== undefined) {
            obj.maxBudget = Math.round(message.maxBudget);
        }
        if (message.outputPrice !== undefined) {
            obj.outputPrice = message.outputPrice;
        }
        if (message.outputPriceTiers?.length) {
            obj.outputPriceTiers = message.outputPriceTiers.map((e) => PriceTier.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ThinkingConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseThinkingConfig();
        message.maxBudget = object.maxBudget ?? undefined;
        message.outputPrice = object.outputPrice ?? undefined;
        message.outputPriceTiers = object.outputPriceTiers?.map((e) => PriceTier.fromPartial(e)) || [];
        return message;
    },
};
function createBaseModelTier() {
    return {
        contextWindow: 0,
        inputPrice: undefined,
        outputPrice: undefined,
        cacheWritesPrice: undefined,
        cacheReadsPrice: undefined,
    };
}
export const ModelTier = {
    encode(message, writer = new BinaryWriter()) {
        if (message.contextWindow !== 0) {
            writer.uint32(8).int32(message.contextWindow);
        }
        if (message.inputPrice !== undefined) {
            writer.uint32(17).double(message.inputPrice);
        }
        if (message.outputPrice !== undefined) {
            writer.uint32(25).double(message.outputPrice);
        }
        if (message.cacheWritesPrice !== undefined) {
            writer.uint32(33).double(message.cacheWritesPrice);
        }
        if (message.cacheReadsPrice !== undefined) {
            writer.uint32(41).double(message.cacheReadsPrice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModelTier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.contextWindow = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.inputPrice = reader.double();
                    continue;
                }
                case 3: {
                    if (tag !== 25) {
                        break;
                    }
                    message.outputPrice = reader.double();
                    continue;
                }
                case 4: {
                    if (tag !== 33) {
                        break;
                    }
                    message.cacheWritesPrice = reader.double();
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.cacheReadsPrice = reader.double();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            contextWindow: isSet(object.contextWindow) ? globalThis.Number(object.contextWindow) : 0,
            inputPrice: isSet(object.inputPrice) ? globalThis.Number(object.inputPrice) : undefined,
            outputPrice: isSet(object.outputPrice) ? globalThis.Number(object.outputPrice) : undefined,
            cacheWritesPrice: isSet(object.cacheWritesPrice) ? globalThis.Number(object.cacheWritesPrice) : undefined,
            cacheReadsPrice: isSet(object.cacheReadsPrice) ? globalThis.Number(object.cacheReadsPrice) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.contextWindow !== 0) {
            obj.contextWindow = Math.round(message.contextWindow);
        }
        if (message.inputPrice !== undefined) {
            obj.inputPrice = message.inputPrice;
        }
        if (message.outputPrice !== undefined) {
            obj.outputPrice = message.outputPrice;
        }
        if (message.cacheWritesPrice !== undefined) {
            obj.cacheWritesPrice = message.cacheWritesPrice;
        }
        if (message.cacheReadsPrice !== undefined) {
            obj.cacheReadsPrice = message.cacheReadsPrice;
        }
        return obj;
    },
    create(base) {
        return ModelTier.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModelTier();
        message.contextWindow = object.contextWindow ?? 0;
        message.inputPrice = object.inputPrice ?? undefined;
        message.outputPrice = object.outputPrice ?? undefined;
        message.cacheWritesPrice = object.cacheWritesPrice ?? undefined;
        message.cacheReadsPrice = object.cacheReadsPrice ?? undefined;
        return message;
    },
};
function createBaseOpenRouterModelInfo() {
    return {
        maxTokens: undefined,
        contextWindow: undefined,
        supportsImages: undefined,
        supportsPromptCache: false,
        inputPrice: undefined,
        outputPrice: undefined,
        cacheWritesPrice: undefined,
        cacheReadsPrice: undefined,
        description: undefined,
        thinkingConfig: undefined,
        supportsGlobalEndpoint: undefined,
        tiers: [],
    };
}
export const OpenRouterModelInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.maxTokens !== undefined) {
            writer.uint32(8).int32(message.maxTokens);
        }
        if (message.contextWindow !== undefined) {
            writer.uint32(16).int32(message.contextWindow);
        }
        if (message.supportsImages !== undefined) {
            writer.uint32(24).bool(message.supportsImages);
        }
        if (message.supportsPromptCache !== false) {
            writer.uint32(32).bool(message.supportsPromptCache);
        }
        if (message.inputPrice !== undefined) {
            writer.uint32(41).double(message.inputPrice);
        }
        if (message.outputPrice !== undefined) {
            writer.uint32(49).double(message.outputPrice);
        }
        if (message.cacheWritesPrice !== undefined) {
            writer.uint32(57).double(message.cacheWritesPrice);
        }
        if (message.cacheReadsPrice !== undefined) {
            writer.uint32(65).double(message.cacheReadsPrice);
        }
        if (message.description !== undefined) {
            writer.uint32(74).string(message.description);
        }
        if (message.thinkingConfig !== undefined) {
            ThinkingConfig.encode(message.thinkingConfig, writer.uint32(82).fork()).join();
        }
        if (message.supportsGlobalEndpoint !== undefined) {
            writer.uint32(88).bool(message.supportsGlobalEndpoint);
        }
        for (const v of message.tiers) {
            ModelTier.encode(v, writer.uint32(98).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenRouterModelInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.maxTokens = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.contextWindow = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.supportsImages = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.supportsPromptCache = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 41) {
                        break;
                    }
                    message.inputPrice = reader.double();
                    continue;
                }
                case 6: {
                    if (tag !== 49) {
                        break;
                    }
                    message.outputPrice = reader.double();
                    continue;
                }
                case 7: {
                    if (tag !== 57) {
                        break;
                    }
                    message.cacheWritesPrice = reader.double();
                    continue;
                }
                case 8: {
                    if (tag !== 65) {
                        break;
                    }
                    message.cacheReadsPrice = reader.double();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.thinkingConfig = ThinkingConfig.decode(reader, reader.uint32());
                    continue;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.supportsGlobalEndpoint = reader.bool();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.tiers.push(ModelTier.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
            contextWindow: isSet(object.contextWindow) ? globalThis.Number(object.contextWindow) : undefined,
            supportsImages: isSet(object.supportsImages) ? globalThis.Boolean(object.supportsImages) : undefined,
            supportsPromptCache: isSet(object.supportsPromptCache) ? globalThis.Boolean(object.supportsPromptCache) : false,
            inputPrice: isSet(object.inputPrice) ? globalThis.Number(object.inputPrice) : undefined,
            outputPrice: isSet(object.outputPrice) ? globalThis.Number(object.outputPrice) : undefined,
            cacheWritesPrice: isSet(object.cacheWritesPrice) ? globalThis.Number(object.cacheWritesPrice) : undefined,
            cacheReadsPrice: isSet(object.cacheReadsPrice) ? globalThis.Number(object.cacheReadsPrice) : undefined,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            thinkingConfig: isSet(object.thinkingConfig) ? ThinkingConfig.fromJSON(object.thinkingConfig) : undefined,
            supportsGlobalEndpoint: isSet(object.supportsGlobalEndpoint)
                ? globalThis.Boolean(object.supportsGlobalEndpoint)
                : undefined,
            tiers: globalThis.Array.isArray(object?.tiers) ? object.tiers.map((e) => ModelTier.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxTokens !== undefined) {
            obj.maxTokens = Math.round(message.maxTokens);
        }
        if (message.contextWindow !== undefined) {
            obj.contextWindow = Math.round(message.contextWindow);
        }
        if (message.supportsImages !== undefined) {
            obj.supportsImages = message.supportsImages;
        }
        if (message.supportsPromptCache !== false) {
            obj.supportsPromptCache = message.supportsPromptCache;
        }
        if (message.inputPrice !== undefined) {
            obj.inputPrice = message.inputPrice;
        }
        if (message.outputPrice !== undefined) {
            obj.outputPrice = message.outputPrice;
        }
        if (message.cacheWritesPrice !== undefined) {
            obj.cacheWritesPrice = message.cacheWritesPrice;
        }
        if (message.cacheReadsPrice !== undefined) {
            obj.cacheReadsPrice = message.cacheReadsPrice;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.thinkingConfig !== undefined) {
            obj.thinkingConfig = ThinkingConfig.toJSON(message.thinkingConfig);
        }
        if (message.supportsGlobalEndpoint !== undefined) {
            obj.supportsGlobalEndpoint = message.supportsGlobalEndpoint;
        }
        if (message.tiers?.length) {
            obj.tiers = message.tiers.map((e) => ModelTier.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return OpenRouterModelInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOpenRouterModelInfo();
        message.maxTokens = object.maxTokens ?? undefined;
        message.contextWindow = object.contextWindow ?? undefined;
        message.supportsImages = object.supportsImages ?? undefined;
        message.supportsPromptCache = object.supportsPromptCache ?? false;
        message.inputPrice = object.inputPrice ?? undefined;
        message.outputPrice = object.outputPrice ?? undefined;
        message.cacheWritesPrice = object.cacheWritesPrice ?? undefined;
        message.cacheReadsPrice = object.cacheReadsPrice ?? undefined;
        message.description = object.description ?? undefined;
        message.thinkingConfig =
            object.thinkingConfig !== undefined && object.thinkingConfig !== null
                ? ThinkingConfig.fromPartial(object.thinkingConfig)
                : undefined;
        message.supportsGlobalEndpoint = object.supportsGlobalEndpoint ?? undefined;
        message.tiers = object.tiers?.map((e) => ModelTier.fromPartial(e)) || [];
        return message;
    },
};
function createBaseOpenRouterCompatibleModelInfo() {
    return { models: {} };
}
export const OpenRouterCompatibleModelInfo = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.models).forEach(([key, value]) => {
            OpenRouterCompatibleModelInfo_ModelsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenRouterCompatibleModelInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = OpenRouterCompatibleModelInfo_ModelsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.models[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            models: isObject(object.models)
                ? Object.entries(object.models).reduce((acc, [key, value]) => {
                    acc[key] = OpenRouterModelInfo.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.models) {
            const entries = Object.entries(message.models);
            if (entries.length > 0) {
                obj.models = {};
                entries.forEach(([k, v]) => {
                    obj.models[k] = OpenRouterModelInfo.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return OpenRouterCompatibleModelInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOpenRouterCompatibleModelInfo();
        message.models = Object.entries(object.models ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = OpenRouterModelInfo.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseOpenRouterCompatibleModelInfo_ModelsEntry() {
    return { key: "", value: undefined };
}
export const OpenRouterCompatibleModelInfo_ModelsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            OpenRouterModelInfo.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenRouterCompatibleModelInfo_ModelsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = OpenRouterModelInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? OpenRouterModelInfo.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = OpenRouterModelInfo.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return OpenRouterCompatibleModelInfo_ModelsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOpenRouterCompatibleModelInfo_ModelsEntry();
        message.key = object.key ?? "";
        message.value =
            object.value !== undefined && object.value !== null ? OpenRouterModelInfo.fromPartial(object.value) : undefined;
        return message;
    },
};
function createBaseOpenAiModelsRequest() {
    return { metadata: undefined, baseUrl: "", apiKey: "" };
}
export const OpenAiModelsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.baseUrl !== "") {
            writer.uint32(18).string(message.baseUrl);
        }
        if (message.apiKey !== "") {
            writer.uint32(26).string(message.apiKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOpenAiModelsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.baseUrl = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.apiKey = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
            baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
            apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.baseUrl !== "") {
            obj.baseUrl = message.baseUrl;
        }
        if (message.apiKey !== "") {
            obj.apiKey = message.apiKey;
        }
        return obj;
    },
    create(base) {
        return OpenAiModelsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOpenAiModelsRequest();
        message.metadata =
            object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined;
        message.baseUrl = object.baseUrl ?? "";
        message.apiKey = object.apiKey ?? "";
        return message;
    },
};
export const ModelsServiceDefinition = {
    name: "ModelsService",
    fullName: "cline.ModelsService",
    methods: {
        /** Fetches available models from Ollama */
        getOllamaModels: {
            name: "getOllamaModels",
            requestType: StringRequest,
            requestStream: false,
            responseType: StringArray,
            responseStream: false,
            options: {},
        },
        /** Fetches available models from LM Studio */
        getLmStudioModels: {
            name: "getLmStudioModels",
            requestType: StringRequest,
            requestStream: false,
            responseType: StringArray,
            responseStream: false,
            options: {},
        },
        /** Fetches available models from VS Code LM API */
        getVsCodeLmModels: {
            name: "getVsCodeLmModels",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: VsCodeLmModelsArray,
            responseStream: false,
            options: {},
        },
        /** Refreshes and returns OpenRouter models */
        refreshOpenRouterModels: {
            name: "refreshOpenRouterModels",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: OpenRouterCompatibleModelInfo,
            responseStream: false,
            options: {},
        },
        /** Refreshes and returns OpenAI models */
        refreshOpenAiModels: {
            name: "refreshOpenAiModels",
            requestType: OpenAiModelsRequest,
            requestStream: false,
            responseType: StringArray,
            responseStream: false,
            options: {},
        },
        /** Refreshes and returns Requesty models */
        refreshRequestyModels: {
            name: "refreshRequestyModels",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: OpenRouterCompatibleModelInfo,
            responseStream: false,
            options: {},
        },
        /** Subscribe to OpenRouter models updates */
        subscribeToOpenRouterModels: {
            name: "subscribeToOpenRouterModels",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: OpenRouterCompatibleModelInfo,
            responseStream: true,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=models.js.map