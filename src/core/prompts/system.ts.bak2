import { getShell } from "../../utils/shell"
import os from "os"
import osName from "os-name"
import { McpHub } from "../../services/mcp/McpHub"
import { BrowserSettings } from "../../shared/BrowserSettings"
import fs from "fs/promises"
import path from "path"
import * as corePrompt from "./core_system_prompt.json"

interface ToolDefinition {
	description: string
	params: {
		[key: string]: {
			type: string
			required: boolean
			desc: string
		}
	}
}

interface RulesJson {
	rules: string[]
}

interface SectionJson {
	content: string
}

/**
 * Loads JSON file from specified path
 */
async function loadJsonFile<T>(filePath: string): Promise<T> {
	try {
		const content = await fs.readFile(filePath, 'utf-8')
		return JSON.parse(content) as T
	} catch (error) {
		console.error(`Error loading JSON from ${filePath}:`, error)
		throw error
	}
}

/**
 * Loads a section from either JSON or markdown file
 */
async function loadSection(sectionsDir: string, sectionName: string): Promise<string> {
	try {
		const jsonPath = path.join(sectionsDir, `${sectionName}.json`)
		const jsonContent = await loadJsonFile<SectionJson>(jsonPath)
		return jsonContent.content
	} catch (error) {
		console.error(`Error loading section ${sectionName}:`, error)
		// Fallback to markdown file if JSON loading fails
		const mdPath = path.join(sectionsDir, `${sectionName}.md`)
		return await fs.readFile(mdPath, 'utf-8')
	}
}

/**
 * Loads rules from JSON file
 */
async function loadRules(rulesDir: string, ruleName: string): Promise<string[]> {
	try {
		const jsonPath = path.join(rulesDir, `${ruleName}.json`)
		const rulesContent = await loadJsonFile<RulesJson>(jsonPath)
		return rulesContent.rules
	} catch (error) {
		console.error(`Error loading rules ${ruleName}:`, error)
		// Fallback to markdown if JSON loading fails
		const mdPath = path.join(rulesDir, `${ruleName}.md`)
		const content = await fs.readFile(mdPath, 'utf-8')
		return [content]
	}
}

export const SYSTEM_PROMPT = async (
	cwd: string,
	supportsComputerUse: boolean,
	mcpHub: McpHub,
	browserSettings: BrowserSettings,
): Promise<string> => {
	const promptsDir = path.join(__dirname, '..')
	const sectionsDir = path.join(promptsDir, 'sections')
	const rulesDir = path.join(promptsDir, 'rules')
	
	// Use directly imported core system prompt JSON
	// No need to load from file path which can cause path resolution issues
	
	// 현재 모드 결정
	const currentMode = supportsComputerUse ? 'act_mode' : 'plan_mode'
	const modeConfig = corePrompt.modes[currentMode]
	
	// 기본 프롬프트 구성
	let systemPrompt = `You are Cline, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.

====

TOOL USE

You have access to a set of tools that are executed upon the user's approval. You can use one tool per message, and will receive the result of that tool use in the user's response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use.

# Tool Use Formatting

Tool use is formatted using XML-style tags. The tool name is enclosed in opening and closing tags, and each parameter is similarly enclosed within its own set of tags. Here's the structure:

<tool_name>
<parameter1_name>value1</parameter1_name>
<parameter2_name>value2</parameter2_name>
...
</tool_name>

For example:

<read_file>
<path>src/main.js</path>
</read_file>

Always adhere to this format for the tool use to ensure proper parsing and execution.`

	// 섹션 로딩 로직
	try {
		for (const sectionRef of modeConfig.sections_ref) {
			try {
				const sectionContent = await loadSection(sectionsDir, sectionRef.replace('.json', ''))
				systemPrompt += '\n\n' + sectionContent
			} catch (error) {
				console.error(`Error loading section ${sectionRef}:`, error)
				// 오류가 있어도 계속 진행
			}
		}
	} catch (error) {
		console.error("Error loading sections:", error)
	}
	
	return systemPrompt
}

export function addUserInstructions(
	settingsCustomInstructions?: string,
	clineRulesFileInstructions?: string,
	clineIgnoreInstructions?: string,
	preferredLanguageInstructions?: string,
): string {
	let customInstructions = ""
	if (preferredLanguageInstructions) {
		customInstructions += preferredLanguageInstructions + "\n\n"
	}
	if (settingsCustomInstructions) {
		customInstructions += settingsCustomInstructions + "\n\n"
	}
	if (clineRulesFileInstructions) {
		customInstructions += clineRulesFileInstructions + "\n\n"
	}
	if (clineIgnoreInstructions) {
		customInstructions += clineIgnoreInstructions
	}

	return `
====

USER'S CUSTOM INSTRUCTIONS

The following additional instructions are provided by the user, and should be followed to the best of your ability without interfering with the TOOL USE guidelines.

${customInstructions.trim()}`
}
