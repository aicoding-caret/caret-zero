## 2. 병합 실행 (Execution)

### 2.1. Upstream 소스 코드 빌드 및 테스트 선행

본격적인 병합 작업을 시작하기 전에, `cline-upstream` 저장소의 최신 코드를 로컬 환경에 준비(clone 또는 checkout)한 후 다음 단계를 반드시 수행합니다:

1.  **의존성 설치:** `npm install` (또는 `yarn install`) 명령을 사용하여 `cline-upstream` 프로젝트의 모든 의존성을 설치합니다.
2.  **전체 빌드 수행:** `package.json`에 명시된 빌드 명령어(예: `npm run compile`)를 실행하여 프로젝트 전체가 오류 없이 빌드되는지 확인합니다.
3.  **(선택 사항) 주요 기능 테스트:** 가능하다면, `cline-upstream`의 주요 기능들이 정상적으로 동작하는지 기본적인 테스트를 수행합니다.

**오류 발견 시 대응:**

*   만약 위 과정에서 빌드 오류나 심각한 테스트 실패가 발견될 경우, **즉시 병합 작업을 중단하고 해당 오류의 원인을 분석**해야 합니다.
*   발견된 오류는 병합 계획 문서(예: `Task-XXX-01-plan-...md`)에 상세히 기록하고, 팀(마스터)과 공유하여 해결 방안을 논의합니다.
*   오류의 심각성 및 프로젝트에 미치는 영향에 따라 다음과 같은 대응을 고려할 수 있습니다:
    *   **Upstream 코드 직접 수정:** `caret-zero`로 가져오기 전에 `cline-upstream` 코드의 오류를 직접 수정합니다. 
        *   **주의:** 이 방식은 Upstream 코드에 대한 깊은 이해가 필요하며, 신중한 접근이 요구됩니다. **섣부른 수정은 예기치 않은 사이드 이펙트를 유발하거나 Upstream의 원래 의도와 다른 코드를 만들 수 있습니다.**
        *   **절차:**
            1.  수정하려는 오류의 원인과 범위를 명확히 분석합니다.
            2.  수정 사항은 최소한으로 유지하고, 해당 변경이 `caret-zero` 프로젝트에 미칠 수 있는 모든 잠재적 영향을 검토합니다.
            3.  모든 수정 내역(변경 전/후 코드, 수정 이유, 테스트 결과 등)을 병합 계획 문서나 별도의 로그에 상세히 기록하고 관리해야 합니다.
            4.  가능하다면, 해당 수정 사항을 원래 `cline-upstream` 프로젝트에 기여(contribute back)하는 것을 고려할 수 있습니다.
            5.  수정된 Upstream 코드를 기반으로 병합을 진행할 경우, 해당 수정 사항이 `caret-zero`의 다른 부분과 충돌하지 않는지 더욱 면밀히 테스트해야 합니다.
    *   **해당 부분 병합 보류/제외:** 문제가 되는 부분은 이번 병합에서 제외하고, 나머지 부분만 선별적으로 병합하는 것을 고려합니다.
    *   **병합 전략 재검토:** Upstream 코드의 품질 문제가 광범위하거나 심각하다고 판단될 경우, 기존 병합 전략을 근본적으로 재검토하고 새로운 접근 방식을 수립합니다.

**주의:** 이 단계를 소홀히 하고 오류가 있는 Upstream 코드를 그대로 병합할 경우, `caret-zero` 프로젝트에 예측 불가능한 심각한 문제를 야기할 수 있으며, 문제 해결에 훨씬 더 많은 시간과 노력이 소요될 수 있습니다.

### 2.2. 파일별 병합 (File-by-File Merging) - AI 도구 활용

**일반 원칙:**
*   **도구 사용 후 확인:** `replace_in_file` 또는 `write_to_file` 사용 후에는 반드시 마스터의 성공/실패 응답과 `final_file_content`를 기다립니다.
*   **섣부른 수정 금지:** 양쪽 코드(Upstream 및 현재 프로젝트)를 비교하여 문제가 식별된 이후라도, 단편적인 정보(예: 에러 메시지, 한쪽 코드 변경 사항)에만 의존하여 성급하게 코드를 수정하려 시도하면 예상치 못한 큰 문제를 야기할 수 있으며, 특히 머징 작업 중에는 더욱 치명적일 수 있습니다. 반드시 양쪽의 변경 사항을 모두 고려하여 근본적인 원인 분석을 선행하고 관련된 모든 영향을 충분히 검토한 후 신중하게 수정해야 합니다.

**병합 우선순위 및 주요 절차:**

1.  **Upstream 단독 변경 파일 우선 적용:**
    *   **대상 식별:** `git diff`를 통해 파악된 `cline-upstream` 변경 목록과 `caret-zero` (현재 프로젝트)의 기준 커밋 이후 변경 목록을 비교하여, `cline-upstream`에서만 수정되고 `caret-zero`에서는 변경되지 않은 파일을 식별합니다.
    *   **적용:** 식별된 파일들은 `cline-upstream` 버전으로 `caret-zero`에 덮어쓰기(`write_to_file`)를 우선적으로 고려합니다. (단, 해당 파일이 우리 커스텀 로직과 전혀 무관한지 재확인 필요)

2.  **전역 문자열 치환 (Branding Alignment):**
    *   Upstream 파일을 가져온 후 (또는 경우에 따라 가져오기 전), 프로젝트 전체 또는 병합 대상 파일들에 대해 다음 문자열 치환을 수행합니다: `cline-docs` 폴더는 제외합니다.
        *   `cline` → `caret`
        *   `Cline` → `Caret`
        *   `CLINE` → `CARET`
    *   이 작업은 `replace_in_file` 도구를 사용하여 파일별로 수행하거나, 마스터의 지시에 따라 더 광범위한 스크립트 실행을 요청할 수 있습니다. 이를 통해 프로젝트의 네이밍 일관성을 확보합니다.

3.  **나머지 파일 순차적/분석적 병합:**
    *   위 두 단계를 거친 후 남은 파일들 (양쪽 모두 변경되었거나, 분석이 필요한 파일들)에 대해 아래의 "단계별 지침"에 따라 순차적으로 병합을 진행합니다.
    *   **사용하지 않는 코드 식별 및 제거:** 병합 과정에서 Upstream의 변경으로 인해 더 이상 사용되지 않는 `caret-zero`의 기존 코드(함수, 변수, 클래스 등)가 있는지 분석합니다. 마스터와 확인 후 안전하게 제거합니다.
    *   **필요한 신규 코드/로직 통합:** Upstream에서 새로 추가되었거나 변경된 기능 중 우리 프로젝트에 필요한 부분을 식별하고 통합합니다. 단순 복사-붙여넣기가 아닌, 기존 `caret-zero` 아키텍처 및 커스텀 로직과의 조화를 고려하여 신중하게 적용합니다.

**단계별 지침:** 