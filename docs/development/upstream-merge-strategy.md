# Cline Upstream 병합 전략 가이드 (AI 작업 지침 포함)

이 문서는 `cline-upstream` 저장소의 변경 사항을 현재 프로젝트(`d:/dev/cline`)에 효과적으로 병합하기 위한 전략과 모범 사례를 제공합니다. 특히 AI(Cline)가 이 문서를 참조하여 병합 작업을 수행할 수 있도록 구체적인 지침을 포함합니다. Task #021 (v3.8.7 -> v3.10.1 병합)의 경험을 바탕으로 작성되었습니다.

## 1. 기본 원칙 (AI 준수 사항)

*   **신중함:** 버전 차이가 클수록 예상치 못한 충돌이나 부작용이 발생할 가능성이 높습니다. 각 변경 사항을 면밀히 검토하고 적용해야 합니다. **절대 서두르지 마세요.**
*   **문서화:** 모든 병합 과정, 사용한 도구(`read_file`, `replace_in_file`, `write_to_file`, `execute_command`, `search_files` 등), 결정 사항(예: 커스텀 로직 유지 결정), 발생한 문제 및 해결 과정을 **반드시** 관련 작업 로그 파일(예: `docs/work-logs/luke-and-alpha/tasks/TASK_ID.md`)에 상세히 기록합니다.
*   **점진적 적용:** 변경 사항을 **파일 단위 또는 더 작은 기능/함수 단위**로 나누어 적용합니다. 각 단계마다 `npm run compile` 명령어를 실행하여 빌드 오류 여부를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **사용자 확인:** 각 도구 사용 후에는 **반드시** 사용자의 확인(성공/실패 결과 및 `final_file_content`)을 기다린 후 다음 단계를 진행합니다. 절대 도구 사용 성공을 가정하지 마세요.
*   **컨텍스트 인지:** 항상 `environment_details`의 파일 목록, 열린 탭, 작업 디렉토리 정보를 확인하여 현재 작업 환경을 정확히 파악합니다.

## 2. 병합 프로세스 (AI 수행 단계)

### 2.1. 사전 분석 (Preparation & Analysis)

1.  **변경 사항 파악:**
    *   `read_file` 도구로 `cline-upstream/CHANGELOG.md` 파일을 읽어 주요 변경 사항 목록을 만듭니다.
    *   병합 대상 파일 목록을 추립니다. (예: Task #021 계획 참고)
    *   필요시 마스터에게 특정 파일에 대한 `git diff --no-index` 실행을 요청하여 구체적인 코드 차이를 확인합니다.
2.  **병합 계획 수립:**
    *   분석 결과를 바탕으로 각 파일별 병합 전략(예: `replace_in_file` 사용, `write_to_file` 사용, 커스텀 로직 유지)을 세웁니다.
    *   **마스터와 상의:** 어떤 커스텀 로직(예: `ILogger` 시스템)을 유지할지, 어떤 Upstream 기능을 선택적으로 가져올지 마스터와 명확히 소통하고 결정합니다.
    *   주요 변경 사항(예: 새로운 도구 추가, 아키텍처 변경)에 대한 병합 순서와 방법을 미리 구상하고 마스터에게 보고합니다.

### 2.2. 파일별 병합 (File-by-File Merging) - AI 도구 활용

**일반 원칙:**

*   **한 번에 한 파일:** 가급적 한 번의 메시지 교환에서는 하나의 파일만 처리합니다.
*   **도구 사용 후 확인:** `replace_in_file` 또는 `write_to_file` 사용 후에는 반드시 마스터의 성공/실패 응답과 `final_file_content`를 기다립니다.

**단계별 지침:**

1.  **의존성 관리 (`package.json`):**
    *   `read_file`로 양쪽 `package.json`을 읽어 `dependencies` 및 `devDependencies` 변경 사항을 비교/분석합니다.
    *   변경 사항이 많으면, 마스터와 상의 후 `write_to_file`로 Upstream 버전으로 덮어쓰거나, `replace_in_file`로 필요한 부분만 수정합니다.
    *   병합 후 `execute_command`로 `npm install` 실행을 요청합니다.
2.  **핵심 모듈 병합 (`src/core`, `src/services`, `src/integrations`, `src/shared`):**
    *   **파일별 비교:** `read_file`로 양쪽 파일을 읽어 변경 내용을 **라인 바이 라인**으로 비교하고 차이점을 분석합니다.
    *   **커스텀 로직 유지:** 마스터가 유지하기로 결정한 커스텀 로직(예: `ILogger`)이 포함된 파일은 **절대 `write_to_file`로 덮어쓰지 않습니다.** `replace_in_file`을 사용하여 Upstream 변경 사항 중 필요한 부분만 신중하게 적용합니다.
    *   **선택적 병합:**
        *   **`replace_in_file` 사용 시 (권장):**
            *   **정확한 `SEARCH` 블록:** **가장 중요합니다.** `replace_in_file` 사용 직전에 **반드시** `read_file`로 최신 파일 내용을 확인하거나, 이전 `replace_in_file` 성공 결과의 `final_file_content`를 **정확히 복사**하여 `SEARCH` 블록을 작성합니다. **절대 이전 기억이나 추측에 의존하지 마세요.**
            *   **작은 단위 변경:** 복잡한 파일(특히 `src/core/task/index.ts`)은 **함수 하나 또는 논리적으로 구분되는 코드 블록(몇 줄 ~ 수십 줄)** 단위로 변경 사항을 나누어 `replace_in_file`을 여러 번 호출합니다. 각 호출 후 성공 여부와 `final_file_content`를 확인하고 진행합니다.
            *   **`search_files` 활용:** `SEARCH` 블록 작성이 어렵거나 대상 코드 주변의 정확한 컨텍스트가 필요할 경우, `search_files` 도구로 확인하여 `SEARCH` 블록의 정확도를 높입니다.
        *   **`write_to_file` 사용 시 (예외적 경우):**
            1.  **마스터 승인:** `replace_in_file` 오류가 3회 이상 반복되거나 변경 범위가 너무 넓어 `replace_in_file`이 비효율적이라고 판단될 경우, **반드시 마스터에게 보고하고 `write_to_file` 사용 승인을 받습니다.**
            2.  **백업:** `execute_command`로 기존 파일을 `.bak` 확장자로 백업합니다. (예: `copy src\\core\\task\\index.ts src\\core\\task\\index.ts.bak`)
            3.  **덮어쓰기:** `write_to_file`로 Upstream 버전을 적용합니다.
            4.  **커스텀 로직 재적용:** 마스터가 유지하기로 결정했던 커스텀 로직을 `replace_in_file`을 사용하여 **작은 단위로** 다시 추가합니다.
    *   **타입 오류 해결:** `npm run compile` 실행 후 발생하는 TypeScript 타입 오류는 오류 메시지를 정확히 분석합니다. 관련된 공유 타입 정의(`src/shared/`) 파일을 `read_file`로 읽어 Upstream과 비교하고, 누락된 타입/속성을 `replace_in_file`로 추가/수정하여 해결합니다.
3.  **UI 병합 (`webview-ui/`):**
    *   핵심 모듈 병합과 동일한 방식으로 파일별 비교 및 선택적 병합을 진행합니다.
    *   `package.json`, `tsconfig.app.json`, `vite.config.ts` 등 설정 파일 변경에 특히 유의합니다.
4.  **시스템 프롬프트 병합 (`src/core/prompts/`):**
    *   **구조 유지:** 현재 프로젝트의 JSON 기반 구조(`core_system_prompt.json`, `sections/*.json`, `rules/*.json`)를 유지합니다. Upstream의 `system.ts` 파일을 직접 사용하지 않습니다.
    *   **내용 분석 및 JSON 반영:** `read_file`로 Upstream `system.ts` 내용을 읽고 분석합니다. 변경된 툴 설명, 가이드라인, 규칙 등을 파악하여, 현재 프로젝트의 해당 JSON 파일(`TOOL_DEFINITIONS.json`, `MCP_CREATION_GUIDE.json`, `rules/*.json` 등)을 `replace_in_file`로 수정하여 반영합니다. **토큰 사용량을 고려하여 핵심 내용 위주로 간결하게 요약/반영합니다.**
    *   **신규 파일 추가:** 새로운 규칙/섹션이 필요하면, 마스터와 상의 후 `write_to_file`로 JSON 파일을 생성하고, `replace_in_file`로 `core_system_prompt.json`의 `rules_ref` 또는 `sections_ref`에 참조를 추가합니다.
5.  **기타 설정 파일 병합:**
    *   `.eslintrc.json`, `tsconfig.json` 등 기타 설정 파일도 `read_file`로 비교 후 `replace_in_file` 또는 `write_to_file`(변경 많을 시, 마스터 승인 후)로 병합합니다.

### 2.3. 빌드 및 테스트 (Build & Test) - AI 요청

*   **주기적 확인:** 파일 병합 단계 중 **하나의 파일 작업 완료 후 또는 중요 변경 후에는 반드시** `execute_command`로 `npm run compile` 실행을 요청하여 컴파일 오류를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **기능 테스트:** 주요 기능(예: API Provider 추가, MCP 기능 변경) 병합 완료 후 마스터에게 관련 기능 테스트를 요청합니다.

## 3. 주요 주의사항 및 팁 (AI 숙지 사항)

*   **`replace_in_file` 오류 대처:**
    *   `SEARCH` 블록 불일치 오류 시, **절대 당황하지 말고** 시스템이 제공하는 `file_content`를 **정확히 복사**하여 `SEARCH` 블록을 수정하고 재시도합니다. **공백, 줄바꿈 하나하나가 중요합니다.**
    *   변경 단위를 더 작게 나누어 시도합니다. (예: 함수 전체 대신 함수 내부의 특정 로직 블록만 변경)
    *   3회 연속 실패 시, **즉시 마스터에게 보고**하고 `write_to_file` 사용 여부 및 대안을 논의합니다.
*   **복잡한 파일 처리 (`src/core/task/index.ts` 등):**
    *   **극도의 신중함:** 작은 단위 변경, `search_files` 활용, Upstream과의 지속적인 비교를 **반드시** 수행합니다.
    *   **작업 중단 가능성 인지:** 작업이 불안정하거나 모델 응답이 중단될 수 있습니다. 문제 발생 시 즉시 마스터에게 상황을 알리고 지침을 받습니다.
*   **커스텀 로직 보호:** 마스터가 유지하기로 결정한 로직(예: `ILogger`)은 **절대** 덮어쓰지 않습니다. 병합 시 해당 부분이 변경되지 않도록 각별히 주의하고, 관련 코드를 수정할 때는 마스터에게 재확인합니다.
*   **컨텍스트 관리:** 작업이 길어지면 컨텍스트 제한(`Context Window Usage`)에 도달할 수 있습니다. 사용량이 80% 이상으로 높아지면 마스터에게 알리고, `new_task` 도구를 사용하여 작업을 분할하거나 작업 중단 및 재개를 요청합니다.
*   **비용 고려:** `replace_in_file` 반복 실패, 복잡한 파일 전체 `write_to_file` 등 비용(시간, 토큰)이 많이 드는 작업 전에는 **반드시** 마스터에게 예상되는 어려움과 비용 증가 가능성을 보고하고 진행 승인을 받습니다.

## 4. 해서는 안 되는 것 (AI 금지 사항)

*   **무분별한 `write_to_file`:** 마스터의 명시적 지시나 3회 이상 `replace_in_file` 실패 없이 파일을 통째로 덮어쓰지 마세요.
*   **빌드 확인 생략:** 컴파일 오류를 확인하지 않고 다음 파일 병합 단계로 넘어가지 마세요.
*   **부정확한 `SEARCH` 블록:** `read_file` 또는 `final_file_content` 확인 없이, 혹은 내용을 일부만 복사하여 `SEARCH` 블록을 작성하지 마세요.
*   **문서화 누락:** 작업 로그 기록을 건너뛰거나 부실하게 작성하지 마세요.
*   **가정 금지:** 도구 사용 성공, 파일 내용, 마스터의 의도 등을 절대 가정하지 말고 항상 확인하고 소통하세요.

이 가이드라인을 따르면 AI가 Upstream 변경 사항을 보다 안전하고 효율적으로 병합하는 데 도움이 될 것입니다. 🌿
</content>
</replace_in_file>
```
# Cline Upstream 병합 전략 가이드 (AI 작업 지침 포함)

이 문서는 `cline-upstream` 저장소의 변경 사항을 현재 프로젝트(`d:/dev/cline`)에 효과적으로 병합하기 위한 전략과 모범 사례를 제공합니다. 특히 AI(Cline)가 이 문서를 참조하여 병합 작업을 수행할 수 있도록 구체적인 지침을 포함합니다. Task #021 (v3.8.7 -> v3.10.1 병합)의 경험을 바탕으로 작성되었습니다.

## 1. 기본 원칙 (AI 준수 사항)

*   **신중함:** 버전 차이가 클수록 예상치 못한 충돌이나 부작용이 발생할 가능성이 높습니다. 각 변경 사항을 면밀히 검토하고 적용해야 합니다. **절대 서두르지 마세요.**
*   **문서화:** 모든 병합 과정, 사용한 도구, 결정 사항, 발생한 문제 및 해결 과정을 **반드시** 관련 작업 로그 파일(예: `docs/work-logs/luke-and-alpha/tasks/TASK_ID.md`)에 상세히 기록합니다.
*   **점진적 적용:** 변경 사항을 **파일 단위 또는 더 작은 기능 단위**로 나누어 적용합니다. 각 단계마다 `npm run compile` 명령어를 실행하여 빌드 오류 여부를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **사용자 확인:** 각 도구 사용 후에는 **반드시** 사용자의 확인(성공/실패 결과)을 기다린 후 다음 단계를 진행합니다. 절대 도구 사용 성공을 가정하지 마세요.

## 2. 병합 프로세스 (AI 수행 단계)

### 2.1. 사전 분석 (Preparation & Analysis)

1.  **변경 사항 파악:**
    *   `cline-upstream/CHANGELOG.md` 파일을 `read_file` 도구로 읽어 주요 변경 사항을 파악합니다.
    *   필요시 마스터에게 `git diff --no-index` 또는 특정 파일 비교를 요청하여 구체적인 코드 차이를 확인합니다.
2.  **병합 계획 수립:**
    *   분석 결과를 바탕으로 어떤 파일을 병합하고, 어떤 커스텀 로직(예: `ILogger` 시스템)을 유지할지 마스터와 상의하여 결정합니다.
    *   주요 변경 사항에 대한 병합 전략을 미리 구상하고 마스터에게 보고합니다. (Task #021의 "병합 시 주요 고려 사항" 참고)

### 2.2. 파일별 병합 (File-by-File Merging) - AI 도구 활용

1.  **의존성 관리 (`package.json`):**
    *   `read_file`로 양쪽 `package.json`을 읽어 `dependencies` 및 `devDependencies` 변경 사항을 비교합니다.
    *   변경 사항이 많으면, 마스터와 상의 후 `write_to_file`로 Upstream 버전으로 덮어쓰거나, `replace_in_file`로 필요한 부분만 수정합니다.
    *   병합 후 마스터에게 `npm install` 실행을 요청합니다. (`execute_command` 사용)
2.  **핵심 모듈 병합 (`src/core`, `src/services`, `src/integrations`, `src/shared`):**
    *   **파일별 비교:** `read_file`로 양쪽 파일을 읽어 변경 내용을 비교합니다.
    *   **커스텀 로직 유지:** 마스터가 유지하기로 결정한 커스텀 로직(예: `ILogger`)이 포함된 파일은 **절대 `write_to_file`로 덮어쓰지 않습니다.** `replace_in_file`을 사용하여 Upstream 변경 사항 중 필요한 부분만 신중하게 적용합니다.
    *   **선택적 병합:**
        *   **`replace_in_file` 사용 시:**
            *   **정확한 `SEARCH` 블록:** **가장 중요합니다.** `replace_in_file` 사용 직전에 **반드시** `read_file`로 최신 파일 내용을 확인하거나, 이전 `replace_in_file` 성공 결과의 `final_file_content`를 참조하여 `SEARCH` 블록을 **정확히** 작성합니다. **절대 이전 기억에 의존하지 마세요.**
            *   **작은 단위 변경:** 복잡한 파일(특히 `src/core/task/index.ts`)은 **함수 하나 또는 몇 줄 단위**로 변경 사항을 나누어 `replace_in_file`을 여러 번 호출합니다. 각 호출 후 성공 여부를 확인하고 진행합니다.
            *   **`search_files` 활용:** `SEARCH` 블록 작성이 어려울 경우, `search_files` 도구로 수정 대상 코드 주변의 정확한 내용을 확인하여 `SEARCH` 블록의 정확도를 높입니다.
        *   **`write_to_file` 사용 시 (예외적 경우):** 변경 사항이 파일 전체에 걸쳐 매우 많거나, `replace_in_file` 오류가 3회 이상 반복될 경우, 마스터와 상의 후 기존 파일을 `.bak` 확장자로 백업(`execute_command` 사용: `copy path/to/file.ts path/to/file.ts.bak`)하고 `write_to_file`로 Upstream 버전을 적용합니다. 이후 필요한 커스텀 로직을 `replace_in_file`로 다시 추가합니다.
    *   **타입 오류 해결:** `npm run compile` 실행 후 발생하는 TypeScript 타입 오류는 오류 메시지를 분석하고, 관련된 공유 타입 정의(`src/shared/`) 파일을 `read_file`로 읽어 Upstream과 비교하여 누락된 타입/속성을 `replace_in_file`로 추가/수정하여 해결합니다.
3.  **UI 병합 (`webview-ui/`):**
    *   핵심 모듈 병합과 동일한 방식으로 파일별 비교 및 선택적 병합을 진행합니다.
    *   `package.json`, `tsconfig.app.json`, `vite.config.ts` 등 설정 파일 변경에 특히 유의합니다.
4.  **시스템 프롬프트 병합 (`src/core/prompts/`):**
    *   **구조 유지:** 현재 프로젝트의 JSON 기반 구조(`core_system_prompt.json`, `sections/*.json`, `rules/*.json`)를 유지합니다. Upstream의 `system.ts` 파일을 직접 사용하지 않습니다.
    *   **내용 분석 및 JSON 반영:** `read_file`로 Upstream `system.ts` 내용을 읽고 분석합니다. 변경된 툴 설명, 가이드라인, 규칙 등을 파악하여, 현재 프로젝트의 해당 JSON 파일(`TOOL_DEFINITIONS.json`, `MCP_CREATION_GUIDE.json`, `rules/*.json` 등)을 `replace_in_file`로 수정하여 반영합니다. **토큰 사용량을 고려하여 간결하게 요약/반영합니다.**
    *   **신규 파일 추가:** 새로운 규칙/섹션이 필요하면, 마스터와 상의 후 `write_to_file`로 JSON 파일을 생성하고, `replace_in_file`로 `core_system_prompt.json`의 `rules_ref` 또는 `sections_ref`에 참조를 추가합니다.
5.  **기타 설정 파일 병합:**
    *   `.eslintrc.json`, `tsconfig.json` 등 기타 설정 파일도 `read_file`로 비교 후 `replace_in_file` 또는 `write_to_file`(변경 많을 시)로 병합합니다.

### 2.3. 빌드 및 테스트 (Build & Test) - AI 요청

*   **주기적 확인:** 파일 병합 단계 중 **중요 변경 후에는 반드시** `execute_command`로 `npm run compile` 실행을 요청하여 컴파일 오류를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **기능 테스트:** 주요 기능 병합 완료 후 마스터에게 관련 기능 테스트를 요청합니다.

## 3. 주요 주의사항 및 팁 (AI 숙지 사항)

*   **`replace_in_file` 오류 대처:**
    *   `SEARCH` 블록 불일치 오류 시, **절대 당황하지 말고** 시스템이 제공하는 `file_content`를 **정확히 복사**하여 `SEARCH` 블록을 수정하고 재시도합니다.
    *   변경 단위를 더 작게 나누어 시도합니다.
    *   3회 연속 실패 시, 마스터에게 보고하고 `write_to_file` 사용 여부를 결정합니다.
*   **복잡한 파일 처리 (`src/core/task/index.ts` 등):**
    *   **극도의 신중함:** 작은 단위 변경, `search_files` 활용, Upstream과의 지속적인 비교를 **반드시** 수행합니다.
    *   **작업 중단 가능성 인지:** 작업이 불안정하거나 중단될 수 있습니다. 문제 발생 시 즉시 마스터에게 보고하고 지침을 받습니다.
*   **커스텀 로직 보호:** 마스터가 유지하기로 결정한 로직은 **절대** 덮어쓰지 않습니다. 병합 시 해당 부분이 변경되지 않도록 각별히 주의합니다.
*   **컨텍스트 관리:** 작업이 길어지면 컨텍스트 제한에 도달할 수 있습니다. `new_task` 도구를 사용하여 작업을 분할하거나, 마스터에게 작업 중단 및 재개를 요청합니다.
*   **비용 고려:** `replace_in_file` 반복 실패, 복잡한 파일 전체 `write_to_file` 등 비용이 많이 드는 작업 전에는 **반드시** 마스터에게 예상 비용(시간, 토큰)을 보고하고 승인을 받습니다.

## 4. 해서는 안 되는 것 (AI 금지 사항)

*   **무분별한 `write_to_file`:** 마스터의 명시적 지시나 3회 이상 `replace_in_file` 실패 없이 파일을 통째로 덮어쓰지 마세요.
*   **빌드 확인 생략:** 컴파일 오류를 확인하지 않고 다음 단계로 넘어가지 마세요.
*   **부정확한 `SEARCH` 블록:** `read_file` 또는 `final_file_content` 확인 없이 `SEARCH` 블록을 작성하지 마세요.
*   **문서화 누락:** 작업 로그 기록을 건너뛰지 마세요.

이 가이드라인을 따르면 AI가 Upstream 변경 사항을 보다 안전하고 효율적으로 병합하는 데 도움이 될 것입니다. 🌿
</content>
</replace_in_file>
```
# Cline Upstream 병합 전략 가이드

이 문서는 `cline-upstream` 저장소의 변경 사항을 현재 프로젝트에 효과적으로 병합하기 위한 전략과 모범 사례를 제공합니다. Task #021 (v3.8.7 -> v3.10.1 병합)의 경험을 바탕으로 작성되었습니다.

## 1. 기본 원칙

*   **신중함:** 버전 차이가 클수록 예상치 못한 충돌이나 부작용이 발생할 가능성이 높습니다. 각 변경 사항을 면밀히 검토하고 적용해야 합니다.
*   **문서화:** 모든 병합 과정, 결정 사항, 발생한 문제 및 해결 과정을 상세히 기록합니다. 이는 추후 유사 작업 시 참고 자료가 되며, 협업 시 중요한 정보가 됩니다. (예: `docs/work-logs/luke-and-alpha/tasks/021-merge-upstream-v3.10.1.md`)
*   **점진적 적용:** 변경 사항을 가능한 작은 단위로 나누어 적용하고, 각 단계마다 빌드 및 테스트를 수행하여 안정성을 확보합니다.

## 2. 병합 프로세스

### 2.1. 사전 분석 (Preparation & Analysis)

1.  **변경 사항 파악:**
    *   `cline-upstream/CHANGELOG.md` 파일을 통해 주요 기능 변경, 개선, 수정 사항을 파악합니다.
    *   필요시 `git diff --no-index` 또는 Git 히스토리를 사용하여 현재 버전과의 구체적인 코드 차이를 확인합니다.
2.  **병합 계획 수립:**
    *   분석 결과를 바탕으로 어떤 파일을 병합하고, 어떤 커스텀 로직을 유지할지 결정합니다.
    *   주요 변경 사항(예: 새로운 도구 추가, 아키텍처 변경, 주요 기능 수정)에 대한 병합 전략을 미리 구상합니다. (Task #021의 "병합 시 주요 고려 사항" 참고)

### 2.2. 파일별 병합 (File-by-File Merging)

1.  **의존성 관리 (`package.json`):**
    *   Upstream의 `dependencies` 및 `devDependencies` 변경 사항을 확인합니다.
    *   필요한 패키지를 추가/업데이트하고, 불필요한 패키지는 제거합니다.
    *   변경 사항이 많을 경우, `write_to_file` 도구를 사용하여 전체 파일을 업데이트하는 것이 효율적일 수 있습니다.
    *   병합 후 반드시 `npm install`을 실행하여 의존성을 설치/업데이트합니다.
2.  **핵심 모듈 병합 (`src/core`, `src/services`, `src/integrations`, `src/shared`):**
    *   **파일별 비교:** `git diff --no-index` 등을 사용하여 각 파일의 변경 내용을 상세히 비교합니다.
    *   **커스텀 로직 유지:** 현재 프로젝트에서 의도적으로 수정한 커스텀 로직(예: `ILogger` 기반 로깅 시스템)은 유지하는 것을 원칙으로 합니다. Upstream 변경 사항을 적용할 때 해당 커스텀 코드가 덮어쓰이지 않도록 주의합니다.
    *   **선택적 병합:**
        *   변경 사항이 적거나 특정 부분만 수정해야 할 경우, `replace_in_file` 도구를 사용합니다.
            *   **정확한 `SEARCH` 블록:** `replace_in_file` 사용 시, `SEARCH` 블록은 **반드시** 도구 실행 직전의 `final_file_content` 또는 오류 시 `file_content`를 참조하여 **정확하게** 작성해야 합니다. (Task #021에서 반복된 오류 원인)
            *   **작은 단위 변경:** 복잡한 파일(특히 `src/core/task/index.ts`)은 함수 또는 몇 줄 단위로 변경 사항을 나누어 적용하고, 각 단계마다 확인합니다.
            *   **`search_files` 활용:** `SEARCH` 블록의 정확도를 높이기 위해 `search_files` 도구로 수정 대상 코드 주변의 정확한 내용을 미리 확인하는 것이 좋습니다.
        *   변경 사항이 많거나 파일 구조가 크게 변경된 경우, 또는 `replace_in_file` 오류가 반복될 경우, 기존 파일을 `.bak` 확장자로 백업하고 `write_to_file` 도구를 사용하여 Upstream 버전으로 덮어쓴 후 필요한 커스텀 로직을 다시 적용하는 방식을 고려할 수 있습니다. (Task #021의 접근 방식 변경 참고)
    *   **타입 오류 해결:** 병합 후 발생하는 TypeScript 타입 오류는 관련된 공유 타입 정의(`src/shared/`) 파일(예: `WebviewMessage.ts`, `ExtensionMessage.ts`, `api.ts`, `mcp.ts`)의 누락된 타입이나 속성을 Upstream과 비교하여 추가/수정하여 해결합니다.
3.  **UI 병합 (`webview-ui/`):**
    *   UI 관련 파일들도 파일별 비교를 통해 변경 사항을 적용합니다.
    *   특히 `package.json`의 의존성, `tsconfig.app.json`, `vite.config.ts` 등의 설정 파일 변경에 유의합니다.
4.  **시스템 프롬프트 병합 (`src/core/prompts/`):**
    *   **구조 유지:** 현재 프로젝트의 JSON 기반 프롬프트 구조를 유지합니다. Upstream의 `system.ts` (텍스트 기반) 내용을 직접 덮어쓰지 않습니다.
    *   **내용 분석 및 반영:** Upstream `system.ts` 파일의 내용을 분석하여, 변경된 툴 설명, 가이드라인, 규칙 등을 현재 프로젝트의 해당 JSON 파일(`TOOL_DEFINITIONS.json`, `MCP_CREATION_GUIDE.json`, `rules/*.json` 등)에 맞게 수정/추가합니다.
    *   **신규 파일 추가:** 필요한 경우, 새로운 규칙이나 섹션을 위한 JSON 파일을 `rules/` 또는 `sections/` 디렉토리에 추가하고, `core_system_prompt.json`의 `rules_ref` 또는 `sections_ref`에 참조를 추가합니다.
5.  **기타 설정 파일 병합:**
    *   `.eslintrc.json`, `tsconfig.json` 등 기타 설정 파일의 변경 사항도 비교하여 적용합니다.

### 2.3. 빌드 및 테스트 (Build & Test)

*   **주기적 확인:** 파일 병합 과정 중 **수시로** `npm run compile` 명령어를 실행하여 컴파일 오류를 즉시 확인하고 해결합니다.
*   **기능 테스트:** 주요 기능 병합 후에는 관련 기능을 직접 테스트하여 예상대로 작동하는지 확인합니다.

## 3. 주요 주의사항 및 팁

*   **`replace_in_file` 오류:**
    *   가장 흔한 오류는 `SEARCH` 블록 불일치입니다. 항상 최신 파일 내용을 기반으로 `SEARCH` 블록을 작성해야 합니다.
    *   변경 사항을 너무 크게 잡거나 여러 `SEARCH/REPLACE` 블록을 한 번에 사용하면 오류 발생 가능성이 높아집니다. 작고 명확한 단위로 나누세요.
    *   오류 발생 시, 시스템이 제공하는 `file_content`를 보고 `SEARCH` 블록을 수정하여 재시도합니다. 반복 실패 시 `write_to_file`을 고려하되, 이는 최후의 수단입니다.
*   **복잡한 파일 처리 (`src/core/task/index.ts` 등):**
    *   매우 신중하게 접근해야 합니다. 작은 단위 변경, `search_files` 활용, Upstream과의 지속적인 비교가 필수적입니다.
    *   모델(AI)의 한계로 인해 작업이 불안정해지거나 중단될 수 있습니다. (Task #021 경험) 이 경우, 접근 방식을 변경(예: Upstream 코드를 기반으로 최소 수정)하거나, 모델 변경 후 재시도하는 것을 고려해야 합니다.
*   **커스텀 로직:** 병합 과정에서 현재 프로젝트의 중요한 커스텀 로직(예: 로깅 시스템)이 실수로 제거되지 않도록 각별히 주의하고, 유지하기로 결정했다면 관련 내용을 명확히 기록합니다.
*   **컨텍스트 관리:** 장시간 작업 시 AI의 컨텍스트 창 제한에 도달할 수 있습니다. 작업 중단 및 재개가 필요할 수 있으며, `new_task` 도구를 활용하여 컨텍스트를 관리하는 것도 방법입니다.
*   **비용 고려:** 병합 작업은 상당한 시간과 토큰(비용)을 소모할 수 있습니다. 복잡한 파일 수정이나 반복적인 오류 해결 시 비용이 크게 증가할 수 있으므로, 예상 비용이 클 경우 마스터에게 보고하고 진행 여부를 결정합니다.

## 4. 해서는 안 되는 것 (Don'ts)

*   **무분별한 덮어쓰기:** 변경 내용을 비교하지 않고 무작정 Upstream 파일로 덮어쓰지 마세요. 중요한 커스텀 로직이 유실될 수 있습니다.
*   **빌드 확인 소홀:** 컴파일 오류를 무시하고 계속 진행하지 마세요. 작은 오류가 누적되어 나중에 해결하기 어려운 큰 문제로 이어질 수 있습니다.
*   **`replace_in_file` `SEARCH` 블록 부정확:** `SEARCH` 블록을 대충 작성하지 마세요. 정확히 일치하지 않으면 도구 실행이 실패하고 작업이 지연됩니다.
*   **문서화 누락:** 변경 내용이나 결정 사항 기록을 소홀히 하지 마세요. 미래의 자신 또는 다른 팀원이 어려움을 겪을 수 있습니다.

이 가이드라인을 따르면 Upstream 변경 사항을 보다 안전하고 효율적으로 병합할 수 있을 것입니다. 🌿
