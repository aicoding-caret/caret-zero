# 마크다운 vs JSON 프롬프트 비교 예시

아래는 동일한 시스템 프롬프트 내용이 마크다운과 JSON 형식으로 어떻게 다르게 표현되는지 보여주는 예시입니다. 이 비교는 마크다운-JSON 쌍 구조 기술의 핵심 이점을 명확히 설명합니다.

## 예시 1: 도구 사용 설명

### 마크다운 버전 (인간 개발자용)

```markdown
# 파일 편집하기

파일을 작업할 때는 다음 두 가지 도구 중 하나를 사용해야 합니다:

## write_to_file

**목적**: 새 파일을 생성하거나 기존 파일의 전체 내용을 덮어씁니다.

**사용 시기**:
- 초기 파일 생성 시
- 파일 전체 내용을 한 번에 교체할 때
- 변경 사항이 너무 복잡하거나 많아서 replace_in_file이 비효율적일 때

**중요 고려사항**:
- 파일의 전체 최종 내용을 제공해야 합니다.
- 기존 파일은 완전히 덮어쓰게 됩니다.

## replace_in_file

**목적**: 파일의 특정 부분만 수정합니다.

**사용 시기**:
- 파일 일부만 수정할 때
- 작은 변경 사항이나 지역화된 수정에 적합

**중요 고려사항**:
- 정확한 SEARCH 블록을 사용하여 대체할 내용을 지정해야 합니다.
- 파일이 매우 긴 경우 전체 파일 내용을 다시 전송하지 않아도 됩니다.
```

### JSON 버전 (AI 모델용)

```json
{
  "title": "파일 편집하기",
  "tools": [
    {
      "name": "write_to_file",
      "purpose": "새 파일 생성 또는 기존 파일 덮어쓰기",
      "use_cases": ["초기 파일 생성", "전체 내용 교체", "복잡한 변경"],
      "considerations": ["전체 최종 내용 제공 필요", "기존 파일 완전 덮어쓰기"]
    },
    {
      "name": "replace_in_file",
      "purpose": "파일 특정 부분 수정",
      "use_cases": ["파일 일부 수정", "작은 지역화된 변경"],
      "considerations": ["정확한 SEARCH 블록 필요", "긴 파일 전체 재전송 불필요"]
    }
  ]
}
```

## 예시 2: 규칙 설명

### 마크다운 버전 (인간 개발자용)

```markdown
# 규칙

코드 작성 시 다음 규칙을 항상 준수해야 합니다:

1. **명확한 변수명 사용**: 변수명은 해당 변수의 용도를 명확히 반영해야 합니다. 한 글자 변수명이나 의미가 모호한 이름은 피하세요.
   예: `n` 대신 `count` 또는 `numStudents` 사용

2. **함수는 한 가지 작업만 수행**: 각 함수는 단일 책임을 가져야 합니다. 여러 작업을 수행하는 함수는 작은 함수로 분리하세요.
   예: 데이터 가져오기, 처리, 표시를 하나의 함수가 아닌 별도 함수로 분리

3. **주석 작성**: 복잡한 로직이나 비즈니스 규칙을 구현하는 경우 그 이유와 방법을 명확히 설명하는 주석을 추가하세요.
   예: 비정상적으로 보이는 예외 처리나 특별한 최적화 설명

4. **적절한 에러 처리**: 모든 외부 상호 작용(파일 읽기, API 호출 등)에는 적절한 에러 처리를 포함해야 합니다.
   예: try-catch 블록 사용 및 의미 있는 에러 메시지 제공

5. **일관된 코딩 스타일**: 프로젝트 전체에서 일관된 들여쓰기, 중괄호 배치, 네이밍 규칙을 유지하세요.
   예: 카멜케이스 vs 스네이크케이스 혼용 금지
```

### JSON 버전 (AI 모델용)

```json
{
  "rules": [
    {
      "id": "clear_variable_names",
      "description": "명확한 변수명 사용",
      "detail": "변수명은 용도를 반영해야 함",
      "avoid": ["한 글자 변수명", "모호한 이름"],
      "example": "`n` 대신 `count`나 `numStudents` 사용"
    },
    {
      "id": "single_responsibility",
      "description": "함수는 한 가지 작업만 수행",
      "detail": "각 함수는 단일 책임을 가져야 함",
      "recommendation": "여러 작업 함수를 작은 함수로 분리",
      "example": "데이터 가져오기, 처리, 표시를 별도 함수로 분리"
    },
    {
      "id": "comments",
      "description": "주석 작성",
      "when": ["복잡한 로직", "비즈니스 규칙 구현"],
      "explain": ["이유", "방법"],
      "example": "비정상적 예외 처리나 특별 최적화 설명"
    },
    {
      "id": "error_handling",
      "description": "적절한 에러 처리",
      "apply_to": ["파일 읽기", "API 호출", "외부 상호 작용"],
      "example": "try-catch 및 의미 있는 에러 메시지"
    },
    {
      "id": "consistent_style",
      "description": "일관된 코딩 스타일",
      "include": ["들여쓰기", "중괄호 배치", "네이밍 규칙"],
      "avoid": "카멜케이스와 스네이크케이스 혼용"
    }
  ]
}
```

## 분석

위 예시들에서 볼 수 있듯이 두 형식 간에는 다음과 같은 차이점이 있습니다:

1. **토큰 효율성**: JSON 버전은 불필요한 설명 텍스트, 서식 마크업, 반복되는 구조 등을 제거하여 토큰 수를 크게 줄입니다.

2. **구조적 명확성**: JSON은 명확한 계층 구조를 제공하여 정보 조직을 개선합니다. 도구나 규칙 간의 관계가 명시적으로 표현됩니다.

3. **프로그래매틱 접근성**: JSON 형식은 프로그래밍 방식으로 쉽게 조작, 필터링, 변환할 수 있습니다. 특정 규칙만 선택하거나 조건부로 규칙을 포함하는 것이 용이합니다.

4. **인간 가독성 대 기계 효율성**: 마크다운은 인간 개발자에게 더 읽기 쉽고 친숙한 반면, JSON은 AI 모델에게 더 효율적입니다. 마크다운-JSON 쌍 구조는 두 세계의 장점을 모두 제공합니다.

이 비교는 마크다운-JSON 쌍 구조 기술이 왜 기존 마크다운만 사용하는 방식보다 더 효율적이고 유연한지를 명확히 보여줍니다.
