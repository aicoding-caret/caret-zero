**주의사항 (AI 병합 작업 시 반드시 숙지)**

*   **‼️ 가장 중요: 병합 대상 파일 목록은 반드시 `git diff`로 확인 ‼️**
    *   Upstream 변경 사항 병합 시, 병합 대상 파일 목록은 **절대로 `CHANGELOG.md` 분석에만 의존하여 추정해서는 안 됩니다.**
    *   반드시 `git diff <이전_버전_태그> <최신_버전_태그> --name-only` 와 같은 `git` 명령어를 사용하여 **실제로 변경된 파일 목록을 정확하게 파악**해야 합니다.
    *   `CHANGELOG.md`는 주요 변경 사항을 이해하는 데 참고 자료로만 활용하고, 실제 병합 대상 파일 선정은 `git diff` 결과를 기반으로 해야 정확하고 누락 없는 병합이 가능합니다.
*   **PowerShell 명령어 체이닝:** PowerShell 환경에서 여러 명령어를 한 줄에 연속으로 실행할 때는 `&&` 대신 세미콜론( `;` )을 사용하거나, 각 명령어를 별도의 `run_terminal_cmd` 호출로 분리하여 실행해야 합니다. `&&` 사용 시 "올바른 문 구분 기호가 아닙니다" 오류가 발생할 수 있습니다.
*   **PowerShell 파이프라인 및 `cat` 사용:** `git tag -l`과 같이 표준 출력으로 결과를 보여주는 명령어의 출력을 확인하고자 할 때, PowerShell에서는 `| cat` (또는 `| Get-Content`)을 사용하면 "입력 개체를 명령에 대한 매개 변수에 바인딩할 수 없습니다"와 유사한 오류가 발생할 수 있습니다. 이 경우 `| cat` 없이 명령어만 단독으로 실행하여 표준 출력을 직접 확인하는 것이 좋습니다.

---

# Cline Upstream 병합 전략 가이드 (AI 작업 지침 포함)

이 문서는 `cline-upstream` 저장소의 변경 사항을 현재 프로젝트에 효과적으로 병합하기 위한 전략과 모범 사례를 제공합니다. 특히 AI(Cline)가 이 문서를 참조하여 병합 작업을 수행할 수 있도록 구체적인 지침을 포함합니다. Task #021 (v3.8.7 -> v3.10.1 병합)의 경험을 바탕으로 작성된 것으로 최신 소스는 cline-upstream에서 최신 버전 작업을 수행합니다.

## 1. 기본 원칙 (AI 준수 사항)

*   **정규 태스크 기반 작업:** 모든 Upstream 병합 활동은 **반드시 정식으로 정의된 태스크**(예: `Task 029: Cline Upstream 변경 사항 병합`)의 일부로 수행되어야 합니다. 이 태스크에는 상세한 계획 문서(예: `029-01-plan-merge-cline-upstream.md`)가 포함되어야 합니다.
*   **본 가이드 필수 참조:** 새로운 Upstream 병합 태스크를 시작하고 실행할 때, **항상 이 `cline-upstream-merging-guide.md` 문서를 참조**해야 합니다. 본 가이드는 병합 전략 및 모범 사례를 제공하며, 개별 태스크 계획은 이 가이드의 원칙을 따라 구체적인 실행 단계를 명시해야 합니다.
*   **계획 중심 실행 (Plan-Driven Execution):** AI는 승인된 태스크 계획 문서(예: `029-01-plan-...md`)에 명시된 단계를 **최우선으로 순차적으로 수행**합니다. 각 단계 완료 후에는 해당 계획 항목의 완료 여부를 마스터에게 보고하여 계획서에 반영하도록 요청해야 합니다. 계획에 없는 작업을 수행하거나 순서를 변경해야 할 경우, **반드시 사전에 마스터와 논의하고 명시적인 승인**을 받아야 합니다.
*   **신중함:** 버전 차이가 클수록 예상치 못한 충돌이나 부작용이 발생할 가능성이 높습니다. 각 변경 사항을 면밀히 검토하고 적용해야 합니다. **절대 서두르지 마세요.**
*   **문서화:** 모든 병합 과정, 사용한 도구(`read_file`, `replace_in_file`, `write_to_file`, `execute_command`, `search_files` 등), 결정 사항(예: 커스텀 로직 유지 결정), 발생한 문제 및 해결 과정을 **반드시** 해당 태스크의 작업 로그 파일(예: `caret-docs/tasks/TASK_ID-03-report-merge-upstream.md` 또는 마스터의 일일 로그)에 상세히 기록합니다. **태스크 계획 문서의 진행 상황 업데이트는 마스터에게 요청**합니다.
*   **점진적 적용:** 변경 사항을 **파일 단위 또는 더 작은 기능/함수 단위**로 나누어 적용합니다. 각 단계마다 `npm run compile` 명령어를 실행하여 빌드 오류 여부를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **사용자 확인:** 각 도구 사용 후에는 **반드시** 사용자의 확인(성공/실패 결과 및 `final_file_content`)을 기다린 후 다음 단계를 진행합니다. 절대 도구 사용 성공을 가정하지 마세요.
*   **컨텍스트 인지:** 항상 `environment_details`의 파일 목록, 열린 탭, 작업 디렉토리 정보를 확인하여 현재 작업 환경을 정확히 파악합니다.

## 2. 병합 프로세스 (AI 수행 단계)

### 2.1. 사전 분석 (Preparation & Analysis)

1.  **변경 사항 파악:**
    *   `read_file` 도구로 `cline-upstream/CHANGELOG.md` 파일을 읽어 주요 변경 사항 목록을 만듭니다.
    *   병합 대상 파일 목록을 추립니다. (예: Task #021 계획 참고)
    *   필요시 마스터에게 특정 파일에 대한 `git diff --no-index` 실행을 요청하여 구체적인 코드 차이를 확인합니다.
2.  **병합 계획 수립:**
    *   **상세 태스크 계획 문서 작성:** 분석 결과를 바탕으로, 본 가이드라인(`cline-upstream-merging-guide.md`)을 참조하여 **구체적인 단계별 실행 계획을 담은 태스크 계획 문서**(예: `029-01-plan-merge-cline-upstream.md`)를 작성합니다. 이 계획 문서는 AI가 실제 병합 작업을 수행할 때 주요 지침으로 사용됩니다.
    *   각 파일별 병합 전략(예: `replace_in_file` 사용, `write_to_file` 사용, 커스텀 로직 유지)을 태스크 계획 문서에 명시합니다.
    *   **마스터와 상의:** 어떤 커스텀 로직(예: `ILogger` 시스템)을 유지할지, 어떤 Upstream 기능을 선택적으로 가져올지 마스터와 명확히 소통하고 결정하여 태스크 계획에 반영합니다.
    *   주요 변경 사항(예: 새로운 도구 추가, 아키텍처 변경)에 대한 병합 순서와 방법을 태스크 계획에 구체적으로 명시하고 마스터에게 보고/확인 받습니다.

### 2.2. 파일별 병합 (File-by-File Merging) - AI 도구 활용

**일반 원칙:**

*   **한 번에 한 파일:** 가급적 한 번의 메시지 교환에서는 하나의 파일만 처리합니다.
*   **도구 사용 후 확인:** `replace_in_file` 또는 `write_to_file` 사용 후에는 반드시 마스터의 성공/실패 응답과 `final_file_content`를 기다립니다.

**단계별 지침:**

1.  **의존성 관리 (`package.json`):**
    *   `read_file`로 양쪽 `package.json`을 읽어 `dependencies` 및 `devDependencies` 변경 사항을 비교/분석합니다.
    *   변경 사항이 많으면, 마스터와 상의 후 `write_to_file`로 Upstream 버전으로 덮어쓰거나, `replace_in_file`로 필요한 부분만 수정합니다.
    *   병합 후 `execute_command`로 `npm install` 실행을 요청합니다.
2.  **핵심 모듈 병합 (`src/core`, `src/services`, `src/integrations`, `src/shared`):**
    *   **파일별 비교:** `read_file`로 양쪽 파일을 읽어 변경 내용을 **라인 바이 라인**으로 비교하고 차이점을 분석합니다.
    *   **커스텀 로직 유지:** 마스터가 유지하기로 결정한 커스텀 로직(예: `ILogger`)이 포함된 파일은 **절대 `write_to_file`로 덮어쓰지 않습니다.** `replace_in_file`을 사용하여 Upstream 변경 사항 중 필요한 부분만 신중하게 적용합니다.
    *   **선택적 병합:**
        *   **`replace_in_file` 사용 시 (권장):**
            *   **정확한 `SEARCH` 블록:** **가장 중요합니다.** `replace_in_file` 사용 직전에 **반드시** `read_file`로 최신 파일 내용을 확인하거나, 이전 `replace_in_file` 성공 결과의 `final_file_content`를 **정확히 복사**하여 `SEARCH` 블록을 작성합니다. **절대 이전 기억이나 추측에 의존하지 마세요.**
            *   **작은 단위 변경:** 복잡한 파일(특히 `src/core/task/index.ts`)은 **함수 하나 또는 논리적으로 구분되는 코드 블록(몇 줄 ~ 수십 줄)** 단위로 변경 사항을 나누어 `replace_in_file`을 여러 번 호출합니다. 각 호출 후 성공 여부와 `final_file_content`를 확인하고 진행합니다.
            *   **`search_files` 활용:** `SEARCH` 블록 작성이 어렵거나 대상 코드 주변의 정확한 컨텍스트가 필요할 경우, `search_files` 도구로 확인하여 `SEARCH` 블록의 정확도를 높입니다.
        *   **`write_to_file` 사용 시 (예외적 경우):**
            1.  **마스터 승인:** `replace_in_file` 오류가 3회 이상 반복되거나 변경 범위가 너무 넓어 `replace_in_file`이 비효율적이라고 판단될 경우, **반드시 마스터에게 보고하고 `write_to_file` 사용 승인을 받습니다.**
            2.  **백업:** `execute_command`로 기존 파일을 `.bak` 확장자로 백업합니다. (예: `copy src\\core\\task\\index.ts src\\core\\task\\index.ts.bak`)
            3.  **덮어쓰기:** `write_to_file`로 Upstream 버전을 적용합니다.
            4.  **커스텀 로직 재적용:** 마스터가 유지하기로 결정했던 커스텀 로직을 `replace_in_file`을 사용하여 **작은 단위로** 다시 추가합니다.
    *   **타입 오류 해결:** `npm run compile` 실행 후 발생하는 TypeScript 타입 오류는 오류 메시지를 정확히 분석합니다. 관련된 공유 타입 정의(`src/shared/`) 파일을 `read_file`로 읽어 Upstream과 비교하고, 누락된 타입/속성을 `replace_in_file`로 추가/수정하여 해결합니다.
3.  **UI 병합 (`webview-ui/`):**
    *   핵심 모듈 병합과 동일한 방식으로 파일별 비교 및 선택적 병합을 진행합니다.
    *   `package.json`, `tsconfig.app.json`, `vite.config.ts` 등 설정 파일 변경에 특히 유의합니다.
4.  **시스템 프롬프트 병합 (`src/core/prompts/`):**
    *   **구조 유지:** 현재 프로젝트의 JSON 기반 구조(`core_system_prompt.json`, `sections/*.json`, `rules/*.json`)를 유지합니다. Upstream의 `system.ts` 파일을 직접 사용하지 않습니다.
    *   **내용 분석 및 JSON 반영:** `read_file`로 Upstream `system.ts` 내용을 읽고 분석합니다. 변경된 툴 설명, 가이드라인, 규칙 등을 파악하여, 현재 프로젝트의 해당 JSON 파일(`TOOL_DEFINITIONS.json`, `MCP_CREATION_GUIDE.json`, `rules/*.json` 등)을 `replace_in_file`로 수정하여 반영합니다. **토큰 사용량을 고려하여 핵심 내용 위주로 간결하게 요약/반영합니다.**
    *   **신규 파일 추가:** 새로운 규칙/섹션이 필요하면, 마스터와 상의 후 `write_to_file`로 JSON 파일을 생성하고, `replace_in_file`로 `core_system_prompt.json`의 `rules_ref` 또는 `sections_ref`에 참조를 추가합니다.
5.  **기타 설정 파일 병합:**
    *   `.eslintrc.json`, `tsconfig.json` 등 기타 설정 파일도 `read_file`로 비교 후 `replace_in_file` 또는 `write_to_file`(변경 많을 시, 마스터 승인 후)로 병합합니다.

### 2.3. 빌드 및 테스트 (Build & Test) - AI 요청

*   **주기적 확인:** 파일 병합 단계 중 **하나의 파일 작업 완료 후 또는 중요 변경 후에는 반드시** `execute_command`로 `npm run compile` 실행을 요청하여 컴파일 오류를 확인하고, 오류 발생 시 즉시 해결합니다.
*   **기능 테스트:** 주요 기능(예: API Provider 추가, MCP 기능 변경) 병합 완료 후 마스터에게 관련 기능 테스트를 요청합니다.

## 3. 주요 주의사항 및 팁 (AI 숙지 사항)

*   **`replace_in_file` 오류 대처:**
    *   `SEARCH` 블록 불일치 오류 시, **절대 당황하지 말고** 시스템이 제공하는 `file_content`를 **정확히 복사**하여 `SEARCH` 블록을 수정하고 재시도합니다. **공백, 줄바꿈 하나하나가 중요합니다.**
    *   변경 단위를 더 작게 나누어 시도합니다. (예: 함수 전체 대신 함수 내부의 특정 로직 블록만 변경)
    *   3회 연속 실패 시, **즉시 마스터에게 보고**하고 `write_to_file` 사용 여부 및 대안을 논의합니다.
*   **복잡한 파일 처리 (`src/core/task/index.ts` 등):**
    *   **극도의 신중함:** 작은 단위 변경, `search_files` 활용, Upstream과의 지속적인 비교를 **반드시** 수행합니다.
    *   **작업 중단 가능성 인지:** 작업이 불안정하거나 모델 응답이 중단될 수 있습니다. 문제 발생 시 즉시 마스터에게 상황을 알리고 지침을 받습니다.
*   **커스텀 로직 보호:** 마스터가 유지하기로 결정한 로직(예: `ILogger`)은 **절대** 덮어쓰지 않습니다. 병합 시 해당 부분이 변경되지 않도록 각별히 주의하고, 관련 코드를 수정할 때는 마스터에게 재확인합니다.
*   **컨텍스트 관리:** 작업이 길어지면 컨텍스트 제한(`Context Window Usage`)에 도달할 수 있습니다. 사용량이 80% 이상으로 높아지면 마스터에게 알리고, `new_task` 도구를 사용하여 작업을 분할하거나 작업 중단 및 재개를 요청합니다.
*   **비용 고려:** `replace_in_file` 반복 실패, 복잡한 파일 전체 `write_to_file` 등 비용(시간, 토큰)이 많이 드는 작업 전에는 **반드시** 마스터에게 예상되는 어려움과 비용 증가 가능성을 보고하고 진행 승인을 받습니다.

## 4. 해서는 안 되는 것 (AI 금지 사항)

*   **무분별한 `write_to_file`:** 마스터의 명시적 지시나 3회 이상 `replace_in_file` 실패 없이 파일을 통째로 덮어쓰지 마세요.
*   **빌드 확인 생략:** 컴파일 오류를 확인하지 않고 다음 파일 병합 단계로 넘어가지 마세요.
*   **부정확한 `SEARCH` 블록:** `read_file` 또는 `final_file_content` 확인 없이, 혹은 내용을 일부만 복사하여 `SEARCH` 블록을 작성하지 마세요.
*   **문서화 누락:** 작업 로그 기록을 건너뛰거나 부실하게 작성하지 마세요.
*   **가정 금지:** 도구 사용 성공, 파일 내용, 마스터의 의도 등을 절대 가정하지 말고 항상 확인하고 소통하세요.

이 가이드라인을 따르면 AI가 Upstream 변경 사항을 보다 안전하고 효율적으로 병합하는 데 도움이 될 것입니다. 🌿
