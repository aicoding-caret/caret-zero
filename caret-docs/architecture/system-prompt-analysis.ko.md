# 시스템 프롬프트 아키텍처 분석 (한글)

## 1. 현황 및 문제점

현재 Cline의 시스템 프롬프트는 단일 텍스트 파일 형태로 관리되고 있습니다. 이 방식은 초기 개발 단계에서는 단순하고 직관적이었지만, 기능 확장 및 고도화에 따라 다음과 같은 문제점들이 발생하고 있습니다.

*   **관리의 어려움:** 프롬프트 내용이 길어지고 복잡해짐에 따라 특정 규칙이나 지침을 찾고 수정하기가 점점 어려워지고 있습니다. 특히, 다양한 기능(도구 사용, MCP, 모드 전환 등)에 대한 지침이 혼재되어 있어 가독성이 떨어집니다.
*   **토큰 비효율성:** 모든 규칙과 지침이 매번 API 요청에 포함되어 불필요한 토큰 소모가 발생합니다. 특히, 특정 작업이나 모드에만 관련된 규칙까지 항상 포함되어 비용 및 응답 속도에 영향을 미칩니다.
*   **확장성 부족:** 새로운 기능이나 규칙을 추가할 때 기존 프롬프트 구조에 통합하기가 번거롭습니다. 프로젝트별, 환경별, 사용자별 커스텀 규칙을 적용하는 유연한 구조를 만들기 어렵습니다.
*   **다국어 지원의 어려움:** 현재 구조에서는 다국어 프롬프트를 효율적으로 관리하고 적용하기 어렵습니다.

## 2. 개선 목표

이러한 문제점들을 해결하기 위해 다음과 같은 목표를 설정합니다.

*   **관리 용이성 향상:** 프롬프트를 구조화하고 모듈화하여 가독성을 높이고 유지보수를 용이하게 합니다.
*   **토큰 효율성 증대:** 핵심 프롬프트와 외부 규칙을 분리하여 필요한 정보만 동적으로 로드함으로써 토큰 사용량을 최적화합니다.
*   **확장성 확보:** 다양한 종류의 규칙(글로벌, 프로젝트, 환경, 사용자 정의 등)을 유연하게 추가하고 관리할 수 있는 아키텍처를 구축합니다.
*   **다국어 지원 기반 마련:** 향후 다국어 프롬프트를 체계적으로 지원할 수 있는 구조를 설계합니다.

## 3. 제안 아키텍처: JSON 기반 구조 및 규칙 분리

### 3.1. 핵심 시스템 프롬프트 (JSON 형식)

*   기본적인 AI 역할, 핵심 능력, 필수 지침 등 항상 필요한 최소한의 정보를 JSON 형식으로 정의합니다.
*   이 핵심 프롬프트는 API 요청 시 기본적으로 포함됩니다.
*   JSON 구조는 가독성과 기계적 처리 용이성을 높입니다.

```jsonc
// 예시: core_system_prompt.json
{
  "persona": {
    "name": "Cline",
    "role": "Highly skilled software engineer...",
    // ... 기타 페르소나 정보
  },
  "core_capabilities": [
    "Tool Use (execute_command, read_file, etc.)",
    "File Editing (write_to_file, replace_in_file)",
    "MCP Integration",
    // ... 핵심 능력 목록
  ],
  "core_rules": [
    "Operate within the current working directory.",
    "Use tools iteratively, waiting for confirmation.",
    "Default to replace_in_file for edits.",
    // ... 필수 규칙 목록
  ],
  "modes": {
    "act_mode": {
      "description": "Execute tasks using tools.",
      "available_tools": ["all", "!plan_mode_respond"], // 예시: 도구 접근 제어
      "rules_ref": ["rules/act_mode_rules.json"] // 외부 규칙 참조
    },
    "plan_mode": {
      "description": "Plan and discuss tasks with the user.",
      "available_tools": ["plan_mode_respond", "read_file", "list_files"], // 예시
      "rules_ref": ["rules/plan_mode_rules.json"] // 외부 규칙 참조
    }
  },
  "rule_loading_strategy": "dynamic" // 규칙 로딩 방식 (예: dynamic, static)
}
```

### 3.2. 외부 규칙 파일 (JSON 또는 Markdown)

*   핵심 프롬프트 외의 특정 기능, 도구, 모드, 프로젝트 등에 대한 상세 규칙 및 지침을 별도의 파일로 분리합니다.
*   파일 형식은 JSON 또는 Markdown 등을 사용할 수 있으며, 내용의 성격에 따라 선택합니다. (예: 구조화된 규칙은 JSON, 설명적인 내용은 Markdown)
*   이 규칙 파일들은 필요에 따라 동적으로 로드되어 핵심 프롬프트와 결합됩니다.

**규칙 종류 예시:**

*   `rules/common_rules.json`: 모든 모드에 공통적으로 적용될 수 있는 규칙
*   `rules/tool_specific/execute_command.md`: `execute_command` 도구 사용법 상세 지침
*   `rules/project_specific/.caretrules`: 현재 프로젝트에만 적용되는 규칙 (기존 방식 활용)
*   `rules/mcp_rules.json`: MCP 서버 연동 관련 규칙

### 3.3. 규칙 로딩 및 결합 메커니즘

*   Cline 실행 시점 또는 특정 컨텍스트(예: 모드 변경, 프로젝트 로딩)에서 필요한 규칙 파일들을 식별합니다.
*   핵심 프롬프트(JSON)와 식별된 외부 규칙 파일들을 결합하여 최종 시스템 프롬프트를 동적으로 생성합니다.
*   `.clinerules` 와 같은 기존 메커니즘과의 호환성 및 통합 방안을 고려합니다.

## 4. 기대 효과

*   **토큰 절약:** 작업에 필요한 규칙만 포함하여 API 요청 크기를 줄이고 비용을 절감합니다.
*   **관리 효율 증대:** 규칙이 모듈화되어 특정 규칙을 찾고 수정하기 쉬워집니다.
*   **유연성 및 확장성 향상:** 새로운 기능, 모드, 프로젝트별 규칙을 쉽게 추가하고 관리할 수 있습니다.
*   **가독성 개선:** 핵심 프롬프트가 간결해지고, 관련 규칙들이 별도 파일로 분리되어 이해하기 쉬워집니다.
*   **다국어/개인화 기반:** 향후 다국어 지원 및 사용자 정의 규칙 적용을 위한 구조적 기반을 마련합니다.

## 5. 고려 사항 및 잠재적 위험

*   **규칙 로딩 복잡성:** 동적 로딩 메커니즘 구현 시 복잡성이 증가할 수 있습니다. 규칙 간의 의존성 관리 방안이 필요합니다.
*   **성능 영향:** 규칙 파일을 읽고 결합하는 과정에서 약간의 오버헤드가 발생할 수 있습니다. 성능 테스트 및 최적화가 필요합니다.
*   **기존 시스템과의 호환성:** 기존 `.clinerules` 등과의 통합 방안을 신중하게 설계해야 합니다.
*   **규칙 파편화:** 규칙이 너무 잘게 쪼개지면 전체적인 파악이 어려워질 수 있으므로 적절한 모듈화 수준을 유지해야 합니다.

## 6. 다음 단계

*   핵심 시스템 프롬프트 JSON 스키마 상세 정의
*   외부 규칙 파일 형식 및 구조 표준화
*   규칙 로딩 및 결합 로직 프로토타입 구현
*   기존 프롬프트 내용을 새로운 구조에 맞게 분리 및 변환 계획 수립 (Task 7-2)
*   `rules/mcp_rules.json`: MCP 서버 연동 관련 규칙

### 3.3. 규칙 로딩 및 결합 메커니즘

*   Cline 실행 시점 또는 특정 컨텍스트(예: 모드 변경, 프로젝트 로딩)에서 필요한 규칙 파일들을 식별합니다.
*   핵심 프롬프트(JSON)와 식별된 외부 규칙 파일들을 결합하여 최종 시스템 프롬프트를 동적으로 생성합니다.
*   `.caretrules` 와 같은 기존 메커니즘과의 호환성 및 통합 방안을 고려합니다.

## 4. 기대 효과

*   **토큰 절약:** 작업에 필요한 규칙만 포함하여 API 요청 크기를 줄이고 비용을 절감합니다.
*   **관리 효율 증대:** 규칙이 모듈화되어 특정 규칙을 찾고 수정하기 쉬워집니다.
*   **유연성 및 확장성 향상:** 새로운 기능, 모드, 프로젝트별 규칙을 쉽게 추가하고 관리할 수 있습니다.
*   **가독성 개선:** 핵심 프롬프트가 간결해지고, 관련 규칙들이 별도 파일로 분리되어 이해하기 쉬워집니다.
*   **다국어/개인화 기반:** 향후 다국어 지원 및 사용자 정의 규칙 적용을 위한 구조적 기반을 마련합니다.

## 5. 고려 사항 및 잠재적 위험

*   **규칙 로딩 복잡성:** 동적 로딩 메커니즘 구현 시 복잡성이 증가할 수 있습니다. 규칙 간의 의존성 관리 방안이 필요합니다.
*   **성능 영향:** 규칙 파일을 읽고 결합하는 과정에서 약간의 오버헤드가 발생할 수 있습니다. 성능 테스트 및 최적화가 필요합니다.
*   **기존 시스템과의 호환성:** 기존 `.clinerules` 등과의 통합 방안을 신중하게 설계해야 합니다.
*   **규칙 파편화:** 규칙이 너무 잘게 쪼개지면 전체적인 파악이 어려워질 수 있으므로 적절한 모듈화 수준을 유지해야 합니다.

## 6. 다음 단계

*   핵심 시스템 프롬프트 JSON 스키마 상세 정의
*   외부 규칙 파일 형식 및 구조 표준화
*   규칙 로딩 및 결합 로직 프로토타입 구현
*   기존 프롬프트 내용을 새로운 구조에 맞게 분리 및 변환 계획 수립 (Task 7-2)

## 4. 기대 효과

*   **토큰 절약:** 작업에 필요한 규칙만 포함하여 API 요청 크기를 줄이고 비용을 절감합니다.
*   **관리 효율 증대:** 규칙이 모듈화되어 특정 규칙을 찾고 수정하기 쉬워집니다.
*   **유연성 및 확장성 향상:** 새로운 기능, 모드, 프로젝트별 규칙을 쉽게 추가하고 관리할 수 있습니다.
*   **가독성 개선:** 핵심 프롬프트가 간결해지고, 관련 규칙들이 별도 파일로 분리되어 이해하기 쉬워집니다.
*   **다국어/개인화 기반:** 향후 다국어 지원 및 사용자 정의 규칙 적용을 위한 구조적 기반을 마련합니다.

## 5. 고려 사항 및 잠재적 위험

*   **규칙 로딩 복잡성:** 동적 로딩 메커니즘 구현 시 복잡성이 증가할 수 있습니다. 규칙 간의 의존성 관리 방안이 필요합니다.
*   **성능 영향:** 규칙 파일을 읽고 결합하는 과정에서 약간의 오버헤드가 발생할 수 있습니다. 성능 테스트 및 최적화가 필요합니다.
*   **기존 시스템과의 호환성:** 기존 `.caretrules` 등과의 통합 방안을 신중하게 설계해야 합니다.
*   **규칙 파편화:** 규칙이 너무 잘게 쪼개지면 전체적인 파악이 어려워질 수 있으므로 적절한 모듈화 수준을 유지해야 합니다.

## 6. 다음 단계

*   핵심 시스템 프롬프트 JSON 스키마 상세 정의
*   외부 규칙 파일 형식 및 구조 표준화
*   규칙 로딩 및 결합 로직 프로토타입 구현
*   기존 프롬프트 내용을 새로운 구조에 맞게 분리 및 변환 계획 수립 (Task 7-2)
